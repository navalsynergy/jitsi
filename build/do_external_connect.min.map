{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./react/features/base/util/parseURLParams.js","webpack:///./react/features/base/util/helpers.js","webpack:///./react/features/base/util/uri.js","webpack:///./react/features/base/util/strings.web.js","webpack:///./connection_optimization/do_external_connect.js","webpack:///./react/features/base/config/getRoomName.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","parseURLParams","url","dontParse","source","paramStr","search","hash","params","paramParts","substr","split","length","firstParam","startsWith","forEach","part","param","decoded","decodeURIComponent","replace","undefined","JSON","parse","e","msg","console","error","window","onerror","reportError","String","getBackendSafeRoomName","room","normalize","toLowerCase","encodeURIComponent","createConnectionExternally","location","config","websocket","externalConnectUrl","isRecorder","roomName","path","pathname","substring","lastIndexOf","getRoomName","token","jwt","connectionInfo","XMPPAttachInfo","status","data","checkForConnectHandlerAndConnect","errorCallback","APP","connect","handler","warn"],"mappings":"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","file":"do_external_connect.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/libs/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/* @flow */\r\n\r\nimport { reportError } from './helpers';\r\n\r\n/**\r\n * Parses the query/search or fragment/hash parameters out of a specific URL and\r\n * returns them as a JS object.\r\n *\r\n * @param {URL} url - The URL to parse.\r\n * @param {boolean} dontParse - If falsy, some transformations (for parsing the\r\n * value as JSON) will be executed.\r\n * @param {string} source - If {@code 'search'}, the parameters will parsed out\r\n * of {@code url.search}; otherwise, out of {@code url.hash}.\r\n * @returns {Object}\r\n */\r\nexport function parseURLParams(\r\n        url: URL,\r\n        dontParse: boolean = false,\r\n        source: string = 'hash'): Object {\r\n    const paramStr = source === 'search' ? url.search : url.hash;\r\n    const params = {};\r\n    const paramParts = (paramStr && paramStr.substr(1).split('&')) || [];\r\n\r\n    // Detect and ignore hash params for hash routers.\r\n    if (source === 'hash' && paramParts.length === 1) {\r\n        const firstParam = paramParts[0];\r\n\r\n        if (firstParam.startsWith('/') && firstParam.split('&').length === 1) {\r\n            return params;\r\n        }\r\n    }\r\n\r\n    paramParts.forEach(part => {\r\n        const param = part.split('=');\r\n        const key = param[0];\r\n\r\n        if (!key) {\r\n            return;\r\n        }\r\n\r\n        let value;\r\n\r\n        try {\r\n            value = param[1];\r\n\r\n            if (!dontParse) {\r\n                const decoded = decodeURIComponent(value).replace(/\\\\&/, '&');\r\n\r\n                value = decoded === 'undefined' ? undefined : JSON.parse(decoded);\r\n            }\r\n        } catch (e) {\r\n            reportError(\r\n                e, `Failed to parse URL parameter value: ${String(value)}`);\r\n\r\n            return;\r\n        }\r\n        params[key] = value;\r\n    });\r\n\r\n    return params;\r\n}\r\n","// @flow\r\n\r\n/**\r\n * A helper function that behaves similar to Object.assign, but only reassigns a\r\n * property in target if it's defined in source.\r\n *\r\n * @param {Object} target - The target object to assign the values into.\r\n * @param {Object} source - The source object.\r\n * @returns {Object}\r\n */\r\nexport function assignIfDefined(target: Object, source: Object) {\r\n    const to = Object(target);\r\n\r\n    for (const nextKey in source) {\r\n        if (source.hasOwnProperty(nextKey)) {\r\n            const value = source[nextKey];\r\n\r\n            if (typeof value !== 'undefined') {\r\n                to[nextKey] = value;\r\n            }\r\n        }\r\n    }\r\n\r\n    return to;\r\n}\r\n\r\n/**\r\n * Tries to copy a given text to the clipboard.\r\n * Returns true if the action succeeds.\r\n *\r\n * @param {string} textToCopy - Text to be copied.\r\n * @returns {boolean}\r\n */\r\nexport function copyText(textToCopy: string) {\r\n    const fakeTextArea = document.createElement('textarea');\r\n    let result;\r\n\r\n    // $FlowFixMe\r\n    document.body.appendChild(fakeTextArea);\r\n    fakeTextArea.value = textToCopy;\r\n    fakeTextArea.select();\r\n\r\n    try {\r\n        result = document.execCommand('copy');\r\n    } catch (err) {\r\n        result = false;\r\n    }\r\n\r\n    // $FlowFixMe\r\n    document.body.removeChild(fakeTextArea);\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * Creates a deferred object.\r\n *\r\n * @returns {{promise, resolve, reject}}\r\n */\r\nexport function createDeferred(): Object {\r\n    const deferred = {};\r\n\r\n    deferred.promise = new Promise((resolve, reject) => {\r\n        deferred.resolve = resolve;\r\n        deferred.reject = reject;\r\n    });\r\n\r\n    return deferred;\r\n}\r\n\r\nconst MATCH_OPERATOR_REGEXP = /[|\\\\{}()[\\]^$+*?.-]/g;\r\n\r\n/**\r\n * Escape RegExp special characters.\r\n *\r\n * Based on https://github.com/sindresorhus/escape-string-regexp.\r\n *\r\n * @param {string} s - The regexp string to escape.\r\n * @returns {string}\r\n */\r\nexport function escapeRegexp(s: string) {\r\n    if (typeof s !== 'string') {\r\n        throw new TypeError('Expected a string');\r\n    }\r\n\r\n    return s.replace(MATCH_OPERATOR_REGEXP, '\\\\$&');\r\n}\r\n\r\n/**\r\n * Returns the base URL of the app.\r\n *\r\n * @param {Object} w - Window object to use instead of the built in one.\r\n * @returns {string}\r\n */\r\nexport function getBaseUrl(w: Object = window) {\r\n    const doc = w.document;\r\n    const base = doc.querySelector('base');\r\n\r\n    if (base && base.href) {\r\n        return base.href;\r\n    }\r\n\r\n    const { protocol, host } = w.location;\r\n\r\n    return `${protocol}//${host}`;\r\n}\r\n\r\n/**\r\n * Returns the namespace for all global variables, functions, etc that we need.\r\n *\r\n * @returns {Object} The namespace.\r\n *\r\n * NOTE: After React-ifying everything this should be the only global.\r\n */\r\nexport function getJitsiMeetGlobalNS() {\r\n    if (!window.JitsiMeetJS) {\r\n        window.JitsiMeetJS = {};\r\n    }\r\n\r\n    if (!window.JitsiMeetJS.app) {\r\n        window.JitsiMeetJS.app = {};\r\n    }\r\n\r\n    return window.JitsiMeetJS.app;\r\n}\r\n\r\n/**\r\n * Prints the error and reports it to the global error handler.\r\n *\r\n * @param {Error} e - The error object.\r\n * @param {string} msg - A custom message to print in addition to the error.\r\n * @returns {void}\r\n */\r\nexport function reportError(e: Object, msg: string = '') {\r\n    console.error(msg, e);\r\n    window.onerror && window.onerror(msg, null, null, null, e);\r\n}\r\n","// @flow\r\n\r\nimport { parseURLParams } from './parseURLParams';\r\nimport { normalizeNFKC } from './strings';\r\n\r\n/**\r\n * The app linking scheme.\r\n * TODO: This should be read from the manifest files later.\r\n */\r\nexport const APP_LINK_SCHEME = 'org.jitsi.meet:';\r\n\r\n/**\r\n * A list of characters to be excluded/removed from the room component/segment\r\n * of a conference/meeting URI/URL. The list is based on RFC 3986 and the jxmpp\r\n * library utilized by jicofo.\r\n */\r\nconst _ROOM_EXCLUDE_PATTERN = '[\\\\:\\\\?#\\\\[\\\\]@!$&\\'()*+,;=></\"]';\r\n\r\n/**\r\n * The {@link RegExp} pattern of the authority of a URI.\r\n *\r\n * @private\r\n * @type {string}\r\n */\r\nconst _URI_AUTHORITY_PATTERN = '(//[^/?#]+)';\r\n\r\n/**\r\n * The {@link RegExp} pattern of the path of a URI.\r\n *\r\n * @private\r\n * @type {string}\r\n */\r\nconst _URI_PATH_PATTERN = '([^?#]*)';\r\n\r\n/**\r\n * The {@link RegExp} pattern of the protocol of a URI.\r\n *\r\n * FIXME: The URL class exposed by JavaScript will not include the colon in\r\n * the protocol field. Also in other places (at the time of this writing:\r\n * the DeepLinkingMobilePage.js) the APP_LINK_SCHEME does not include\r\n * the double dots, so things are inconsistent.\r\n *\r\n * @type {string}\r\n */\r\nexport const URI_PROTOCOL_PATTERN = '^([a-z][a-z0-9\\\\.\\\\+-]*:)';\r\n\r\n/**\r\n * Excludes/removes certain characters from a specific room (name) which are\r\n * incompatible with Jitsi Meet on the client and/or server sides.\r\n *\r\n * @param {?string} room - The room (name) to fix.\r\n * @private\r\n * @returns {?string}\r\n */\r\nfunction _fixRoom(room: ?string) {\r\n    return room\r\n        ? room.replace(new RegExp(_ROOM_EXCLUDE_PATTERN, 'g'), '')\r\n        : room;\r\n}\r\n\r\n/**\r\n * Fixes the scheme part of a specific URI (string) so that it contains a\r\n * well-known scheme such as HTTP(S). For example, the mobile app implements an\r\n * app-specific URI scheme in addition to Universal Links. The app-specific\r\n * scheme may precede or replace the well-known scheme. In such a case, dealing\r\n * with the app-specific scheme only complicates the logic and it is simpler to\r\n * get rid of it (by translating the app-specific scheme into a well-known\r\n * scheme).\r\n *\r\n * @param {string} uri - The URI (string) to fix the scheme of.\r\n * @private\r\n * @returns {string}\r\n */\r\nfunction _fixURIStringScheme(uri: string) {\r\n    const regex = new RegExp(`${URI_PROTOCOL_PATTERN}+`, 'gi');\r\n    const match: Array<string> | null = regex.exec(uri);\r\n\r\n    if (match) {\r\n        // As an implementation convenience, pick up the last scheme and make\r\n        // sure that it is a well-known one.\r\n        let protocol = match[match.length - 1].toLowerCase();\r\n\r\n        if (protocol !== 'http:' && protocol !== 'https:') {\r\n            protocol = 'https:';\r\n        }\r\n\r\n        /* eslint-disable no-param-reassign */\r\n\r\n        uri = uri.substring(regex.lastIndex);\r\n        if (uri.startsWith('//')) {\r\n            // The specified URL was not a room name only, it contained an\r\n            // authority.\r\n            uri = protocol + uri;\r\n        }\r\n\r\n        /* eslint-enable no-param-reassign */\r\n    }\r\n\r\n    return uri;\r\n}\r\n\r\n/**\r\n * Converts a path to a backend-safe format, by splitting the path '/' processing each part.\r\n * Properly lowercased and url encoded.\r\n *\r\n * @param {string?} path - The path to convert.\r\n * @returns {string?}\r\n */\r\nexport function getBackendSafePath(path: ?string): ?string {\r\n    if (!path) {\r\n        return path;\r\n    }\r\n\r\n    return path\r\n        .split('/')\r\n        .map(getBackendSafeRoomName)\r\n        .join('/');\r\n}\r\n\r\n/**\r\n * Converts a room name to a backend-safe format. Properly lowercased and url encoded.\r\n *\r\n * @param {string?} room - The room name to convert.\r\n * @returns {string?}\r\n */\r\nexport function getBackendSafeRoomName(room: ?string): ?string {\r\n    if (!room) {\r\n        return room;\r\n    }\r\n\r\n    /* eslint-disable no-param-reassign */\r\n    try {\r\n        // We do not know if we get an already encoded string at this point\r\n        // as different platforms do it differently, but we need a decoded one\r\n        // for sure. However since decoding a non-encoded string is a noop, we're safe\r\n        // doing it here.\r\n        room = decodeURIComponent(room);\r\n    } catch (e) {\r\n        // This can happen though if we get an unencoded string and it contains\r\n        // some characters that look like an encoded entity, but it's not.\r\n        // But in this case we're fine goin on...\r\n    }\r\n\r\n    // Normalize the character set.\r\n    room = normalizeNFKC(room);\r\n\r\n    // Only decoded and normalized strings can be lowercased properly.\r\n    room = room.toLowerCase();\r\n\r\n    // But we still need to (re)encode it.\r\n    room = encodeURIComponent(room);\r\n    /* eslint-enable no-param-reassign */\r\n\r\n    // Unfortunately we still need to lowercase it, because encoding a string will\r\n    // add some uppercase characters, but some backend services\r\n    // expect it to be full lowercase. However lowercasing an encoded string\r\n    // doesn't change the string value.\r\n    return room.toLowerCase();\r\n}\r\n\r\n/**\r\n * Gets the (Web application) context root defined by a specific location (URI).\r\n *\r\n * @param {Object} location - The location (URI) which defines the (Web\r\n * application) context root.\r\n * @public\r\n * @returns {string} - The (Web application) context root defined by the\r\n * specified {@code location} (URI).\r\n */\r\nexport function getLocationContextRoot({ pathname }: { pathname: string }) {\r\n    const contextRootEndIndex = pathname.lastIndexOf('/');\r\n\r\n    return (\r\n        contextRootEndIndex === -1\r\n            ? '/'\r\n            : pathname.substring(0, contextRootEndIndex + 1));\r\n}\r\n\r\n/**\r\n * Constructs a new {@code Array} with URL parameter {@code String}s out of a\r\n * specific {@code Object}.\r\n *\r\n * @param {Object} obj - The {@code Object} to turn into URL parameter\r\n * {@code String}s.\r\n * @returns {Array<string>} The {@code Array} with URL parameter {@code String}s\r\n * constructed out of the specified {@code obj}.\r\n */\r\nfunction _objectToURLParamsArray(obj = {}) {\r\n    const params = [];\r\n\r\n    for (const key in obj) { // eslint-disable-line guard-for-in\r\n        try {\r\n            params.push(\r\n                `${key}=${encodeURIComponent(JSON.stringify(obj[key]))}`);\r\n        } catch (e) {\r\n            console.warn(`Error encoding ${key}: ${e}`);\r\n        }\r\n    }\r\n\r\n    return params;\r\n}\r\n\r\n/**\r\n * Parses a specific URI string into an object with the well-known properties of\r\n * the {@link Location} and/or {@link URL} interfaces implemented by Web\r\n * browsers. The parsing attempts to be in accord with IETF's RFC 3986.\r\n *\r\n * @param {string} str - The URI string to parse.\r\n * @public\r\n * @returns {{\r\n *     hash: string,\r\n *     host: (string|undefined),\r\n *     hostname: (string|undefined),\r\n *     pathname: string,\r\n *     port: (string|undefined),\r\n *     protocol: (string|undefined),\r\n *     search: string\r\n * }}\r\n */\r\nexport function parseStandardURIString(str: string) {\r\n    /* eslint-disable no-param-reassign */\r\n\r\n    const obj: Object = {\r\n        toString: _standardURIToString\r\n    };\r\n\r\n    let regex;\r\n    let match: Array<string> | null;\r\n\r\n    // XXX A URI string as defined by RFC 3986 does not contain any whitespace.\r\n    // Usually, a browser will have already encoded any whitespace. In order to\r\n    // avoid potential later problems related to whitespace in URI, strip any\r\n    // whitespace. Anyway, the Jitsi Meet app is not known to utilize unencoded\r\n    // whitespace so the stripping is deemed safe.\r\n    str = str.replace(/\\s/g, '');\r\n\r\n    // protocol\r\n    regex = new RegExp(URI_PROTOCOL_PATTERN, 'gi');\r\n    match = regex.exec(str);\r\n    if (match) {\r\n        obj.protocol = match[1].toLowerCase();\r\n        str = str.substring(regex.lastIndex);\r\n    }\r\n\r\n    // authority\r\n    regex = new RegExp(`^${_URI_AUTHORITY_PATTERN}`, 'gi');\r\n    match = regex.exec(str);\r\n    if (match) {\r\n        let authority: string = match[1].substring(/* // */ 2);\r\n\r\n        str = str.substring(regex.lastIndex);\r\n\r\n        // userinfo\r\n        const userinfoEndIndex = authority.indexOf('@');\r\n\r\n        if (userinfoEndIndex !== -1) {\r\n            authority = authority.substring(userinfoEndIndex + 1);\r\n        }\r\n\r\n        obj.host = authority;\r\n\r\n        // port\r\n        const portBeginIndex = authority.lastIndexOf(':');\r\n\r\n        if (portBeginIndex !== -1) {\r\n            obj.port = authority.substring(portBeginIndex + 1);\r\n            authority = authority.substring(0, portBeginIndex);\r\n        }\r\n\r\n        // hostname\r\n        obj.hostname = authority;\r\n    }\r\n\r\n    // pathname\r\n    regex = new RegExp(`^${_URI_PATH_PATTERN}`, 'gi');\r\n    match = regex.exec(str);\r\n\r\n    let pathname: ?string;\r\n\r\n    if (match) {\r\n        pathname = match[1];\r\n        str = str.substring(regex.lastIndex);\r\n    }\r\n    if (pathname) {\r\n        pathname.startsWith('/') || (pathname = `/${pathname}`);\r\n    } else {\r\n        pathname = '/';\r\n    }\r\n    obj.pathname = pathname;\r\n\r\n    // query\r\n    if (str.startsWith('?')) {\r\n        let hashBeginIndex = str.indexOf('#', 1);\r\n\r\n        if (hashBeginIndex === -1) {\r\n            hashBeginIndex = str.length;\r\n        }\r\n        obj.search = str.substring(0, hashBeginIndex);\r\n        str = str.substring(hashBeginIndex);\r\n    } else {\r\n        obj.search = ''; // Google Chrome\r\n    }\r\n\r\n    // fragment\r\n    obj.hash = str.startsWith('#') ? str : '';\r\n\r\n    /* eslint-enable no-param-reassign */\r\n\r\n    return obj;\r\n}\r\n\r\n/**\r\n * Parses a specific URI which (supposedly) references a Jitsi Meet resource\r\n * (location).\r\n *\r\n * @param {(string|undefined)} uri - The URI to parse which (supposedly)\r\n * references a Jitsi Meet resource (location).\r\n * @public\r\n * @returns {{\r\n *     contextRoot: string,\r\n *     hash: string,\r\n *     host: string,\r\n *     hostname: string,\r\n *     pathname: string,\r\n *     port: string,\r\n *     protocol: string,\r\n *     room: (string|undefined),\r\n *     search: string\r\n * }}\r\n */\r\nexport function parseURIString(uri: ?string) {\r\n    if (typeof uri !== 'string') {\r\n        return undefined;\r\n    }\r\n\r\n    const obj = parseStandardURIString(_fixURIStringScheme(uri));\r\n\r\n    // Add the properties that are specific to a Jitsi Meet resource (location)\r\n    // such as contextRoot, room:\r\n\r\n    // contextRoot\r\n    obj.contextRoot = getLocationContextRoot(obj);\r\n\r\n    // The room (name) is the last component/segment of pathname.\r\n    const { pathname } = obj;\r\n\r\n    // XXX While the components/segments of pathname are URI encoded, Jitsi Meet\r\n    // on the client and/or server sides still don't support certain characters.\r\n    const contextRootEndIndex = pathname.lastIndexOf('/');\r\n    let room = pathname.substring(contextRootEndIndex + 1) || undefined;\r\n\r\n    if (room) {\r\n        const fixedRoom = _fixRoom(room);\r\n\r\n        if (fixedRoom !== room) {\r\n            room = fixedRoom;\r\n\r\n            // XXX Drive fixedRoom into pathname (because room is derived from\r\n            // pathname).\r\n            obj.pathname\r\n                = pathname.substring(0, contextRootEndIndex + 1) + (room || '');\r\n        }\r\n    }\r\n    obj.room = room;\r\n\r\n    if (contextRootEndIndex > 1) {\r\n        // The part of the pathname from the beginning to the room name is the tenant.\r\n        obj.tenant = pathname.substring(1, contextRootEndIndex);\r\n    }\r\n\r\n    return obj;\r\n}\r\n\r\n/**\r\n * Implements {@code href} and {@code toString} for the {@code Object} returned\r\n * by {@link #parseStandardURIString}.\r\n *\r\n * @param {Object} [thiz] - An {@code Object} returned by\r\n * {@code #parseStandardURIString} if any; otherwise, it is presumed that the\r\n * function is invoked on such an instance.\r\n * @returns {string}\r\n */\r\nfunction _standardURIToString(thiz: ?Object) {\r\n    // eslint-disable-next-line no-invalid-this\r\n    const { hash, host, pathname, protocol, search } = thiz || this;\r\n    let str = '';\r\n\r\n    protocol && (str += protocol);\r\n\r\n    // TODO userinfo\r\n\r\n    host && (str += `//${host}`);\r\n    str += pathname || '/';\r\n    search && (str += search);\r\n    hash && (str += hash);\r\n\r\n    return str;\r\n}\r\n\r\n/**\r\n * Sometimes we receive strings that we don't know if already percent-encoded, or not, due to the\r\n * various sources we get URLs or room names. This function encapsulates the decoding in a safe way.\r\n *\r\n * @param {string} text - The text to decode.\r\n * @returns {string}\r\n */\r\nexport function safeDecodeURIComponent(text: string) {\r\n    try {\r\n        return decodeURIComponent(text);\r\n    } catch (e) {\r\n        // The text wasn't encoded.\r\n    }\r\n\r\n    return text;\r\n}\r\n\r\n/**\r\n * Attempts to return a {@code String} representation of a specific\r\n * {@code Object} which is supposed to represent a URL. Obviously, if a\r\n * {@code String} is specified, it is returned. If a {@code URL} is specified,\r\n * its {@code URL#href} is returned. Additionally, an {@code Object} similar to\r\n * the one accepted by the constructor of Web's ExternalAPI is supported on both\r\n * mobile/React Native and Web/React.\r\n *\r\n * @param {Object|string} obj - The URL to return a {@code String}\r\n * representation of.\r\n * @returns {string} - A {@code String} representation of the specified\r\n * {@code obj} which is supposed to represent a URL.\r\n */\r\nexport function toURLString(obj: ?(Object | string)): ?string {\r\n    let str;\r\n\r\n    switch (typeof obj) {\r\n    case 'object':\r\n        if (obj) {\r\n            if (obj instanceof URL) {\r\n                str = obj.href;\r\n            } else {\r\n                str = urlObjectToString(obj);\r\n            }\r\n        }\r\n        break;\r\n\r\n    case 'string':\r\n        str = String(obj);\r\n        break;\r\n    }\r\n\r\n    return str;\r\n}\r\n\r\n/**\r\n * Attempts to return a {@code String} representation of a specific\r\n * {@code Object} similar to the one accepted by the constructor\r\n * of Web's ExternalAPI.\r\n *\r\n * @param {Object} o - The URL to return a {@code String} representation of.\r\n * @returns {string} - A {@code String} representation of the specified\r\n * {@code Object}.\r\n */\r\nexport function urlObjectToString(o: Object): ?string {\r\n    // First normalize the given url. It come as o.url or split into o.serverURL\r\n    // and o.room.\r\n    let tmp;\r\n\r\n    if (o.serverURL && o.room) {\r\n        tmp = new URL(o.room, o.serverURL).toString();\r\n    } else if (o.room) {\r\n        tmp = o.room;\r\n    } else {\r\n        tmp = o.url || '';\r\n    }\r\n\r\n    const url = parseStandardURIString(_fixURIStringScheme(tmp));\r\n\r\n    // protocol\r\n    if (!url.protocol) {\r\n        let protocol: ?string = o.protocol || o.scheme;\r\n\r\n        if (protocol) {\r\n            // Protocol is supposed to be the scheme and the final ':'. Anyway,\r\n            // do not make a fuss if the final ':' is not there.\r\n            protocol.endsWith(':') || (protocol += ':');\r\n            url.protocol = protocol;\r\n        }\r\n    }\r\n\r\n    // authority & pathname\r\n    let { pathname } = url;\r\n\r\n    if (!url.host) {\r\n        // Web's ExternalAPI domain\r\n        //\r\n        // It may be host/hostname and pathname with the latter denoting the\r\n        // tenant.\r\n        const domain: ?string = o.domain || o.host || o.hostname;\r\n\r\n        if (domain) {\r\n            const { host, hostname, pathname: contextRoot, port }\r\n                = parseStandardURIString(\r\n\r\n                    // XXX The value of domain in supposed to be host/hostname\r\n                    // and, optionally, pathname. Make sure it is not taken for\r\n                    // a pathname only.\r\n                    _fixURIStringScheme(`${APP_LINK_SCHEME}//${domain}`));\r\n\r\n            // authority\r\n            if (host) {\r\n                url.host = host;\r\n                url.hostname = hostname;\r\n                url.port = port;\r\n            }\r\n\r\n            // pathname\r\n            pathname === '/' && contextRoot !== '/' && (pathname = contextRoot);\r\n        }\r\n    }\r\n\r\n    // pathname\r\n\r\n    // Web's ExternalAPI roomName\r\n    const room = o.roomName || o.room;\r\n\r\n    if (room\r\n            && (url.pathname.endsWith('/')\r\n                || !url.pathname.endsWith(`/${room}`))) {\r\n        pathname.endsWith('/') || (pathname += '/');\r\n        pathname += room;\r\n    }\r\n\r\n    url.pathname = pathname;\r\n\r\n    // query/search\r\n\r\n    // Web's ExternalAPI jwt\r\n    const { jwt } = o;\r\n\r\n    if (jwt) {\r\n        let { search } = url;\r\n\r\n        if (search.indexOf('?jwt=') === -1 && search.indexOf('&jwt=') === -1) {\r\n            search.startsWith('?') || (search = `?${search}`);\r\n            search.length === 1 || (search += '&');\r\n            search += `jwt=${jwt}`;\r\n\r\n            url.search = search;\r\n        }\r\n    }\r\n\r\n    // fragment/hash\r\n\r\n    let { hash } = url;\r\n\r\n    for (const urlPrefix of [ 'config', 'interfaceConfig', 'devices', 'userInfo', 'appData' ]) {\r\n        const urlParamsArray\r\n            = _objectToURLParamsArray(\r\n                o[`${urlPrefix}Overwrite`]\r\n                    || o[urlPrefix]\r\n                    || o[`${urlPrefix}Override`]);\r\n\r\n        if (urlParamsArray.length) {\r\n            let urlParamsString\r\n                = `${urlPrefix}.${urlParamsArray.join(`&${urlPrefix}.`)}`;\r\n\r\n            if (hash.length) {\r\n                urlParamsString = `&${urlParamsString}`;\r\n            } else {\r\n                hash = '#';\r\n            }\r\n            hash += urlParamsString;\r\n        }\r\n    }\r\n\r\n    url.hash = hash;\r\n\r\n    return url.toString() || undefined;\r\n}\r\n\r\n/**\r\n * Adds hash params to URL.\r\n *\r\n * @param {URL} url - The URL.\r\n * @param {Object} hashParamsToAdd - A map with the parameters to be set.\r\n * @returns {URL} - The new URL.\r\n */\r\nexport function addHashParamsToURL(url: URL, hashParamsToAdd: Object = {}) {\r\n    const params = parseURLParams(url);\r\n    const urlParamsArray = _objectToURLParamsArray({\r\n        ...params,\r\n        ...hashParamsToAdd\r\n    });\r\n\r\n    if (urlParamsArray.length) {\r\n        url.hash = `#${urlParamsArray.join('&')}`;\r\n    }\r\n\r\n    return url;\r\n}\r\n\r\n/**\r\n * Returns the decoded URI.\r\n *\r\n * @param {string} uri - The URI to decode.\r\n * @returns {string}\r\n */\r\nexport function getDecodedURI(uri: string) {\r\n    return decodeURI(uri.replace(/^https?:\\/\\//i, ''));\r\n}\r\n","// @flow\r\n\r\n/**\r\n * Applies NFKC normalization to the given text.\r\n *\r\n * @param {string} text - The text that needs to be normalized.\r\n * @returns {string} - The normalized text.\r\n */\r\nexport function normalizeNFKC(text: string) {\r\n    return text.normalize('NFKC');\r\n}\r\n","/* global config, createConnectionExternally */\r\n\r\nimport getRoomName from '../react/features/base/config/getRoomName';\r\nimport { parseURLParams } from '../react/features/base/util/parseURLParams';\r\n\r\n/**\r\n * Implements external connect using createConnectionExternally function defined\r\n * in external_connect.js for Jitsi Meet. Parses the room name and JSON Web\r\n * Token (JWT) from the URL and executes createConnectionExternally.\r\n *\r\n * NOTE: If you are using lib-jitsi-meet without Jitsi Meet, you should use this\r\n * file as reference only because the implementation is Jitsi Meet-specific.\r\n *\r\n * NOTE: For optimal results this file should be included right after\r\n * external_connect.js.\r\n */\r\n\r\nif (typeof createConnectionExternally === 'function') {\r\n    // URL params have higher priority than config params.\r\n    // Do not use external connect if websocket is enabled.\r\n    let url\r\n        = parseURLParams(window.location, true, 'hash')[\r\n                'config.externalConnectUrl']\r\n            || config.websocket ? undefined : config.externalConnectUrl;\r\n    const isRecorder\r\n        = parseURLParams(window.location, true, 'hash')['config.iAmRecorder'];\r\n\r\n    let roomName;\r\n\r\n    if (url && (roomName = getRoomName()) && !isRecorder) {\r\n        url += `?room=${roomName}`;\r\n\r\n        const token = parseURLParams(window.location, true, 'search').jwt;\r\n\r\n        if (token) {\r\n            url += `&token=${token}`;\r\n        }\r\n\r\n        createConnectionExternally(\r\n            url,\r\n            connectionInfo => {\r\n                // Sets that global variable to be used later by connect method\r\n                // in connection.js.\r\n                window.XMPPAttachInfo = {\r\n                    status: 'success',\r\n                    data: connectionInfo\r\n                };\r\n                checkForConnectHandlerAndConnect();\r\n            },\r\n            errorCallback);\r\n    } else {\r\n        errorCallback();\r\n    }\r\n} else {\r\n    errorCallback();\r\n}\r\n\r\n/**\r\n * Check if connect from connection.js was executed and executes the handler\r\n * that is going to finish the connect work.\r\n *\r\n * @returns {void}\r\n */\r\nfunction checkForConnectHandlerAndConnect() {\r\n    window.APP\r\n        && window.APP.connect.status === 'ready'\r\n        && window.APP.connect.handler();\r\n}\r\n\r\n/**\r\n * Implements a callback to be invoked if anything goes wrong.\r\n *\r\n * @param {Error} error - The specifics of what went wrong.\r\n * @returns {void}\r\n */\r\nfunction errorCallback(error) {\r\n    // The value of error is undefined if external connect is disabled.\r\n    error && console.warn(error);\r\n\r\n    // Sets that global variable to be used later by connect method in\r\n    // connection.js.\r\n    window.XMPPAttachInfo = {\r\n        status: 'error'\r\n    };\r\n    checkForConnectHandlerAndConnect();\r\n}\r\n","// @flow\r\n\r\nimport { getBackendSafeRoomName } from '../util';\r\n\r\n/**\r\n * Builds and returns the room name.\r\n *\r\n * @returns {string}\r\n */\r\nexport default function getRoomName(): ?string {\r\n    const path = window.location.pathname;\r\n\r\n    // The last non-directory component of the path (name) is the room.\r\n    const roomName = path.substring(path.lastIndexOf('/') + 1) || undefined;\r\n\r\n    return getBackendSafeRoomName(roomName);\r\n}\r\n"],"sourceRoot":""}